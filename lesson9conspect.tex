\documentclass[12pt]{article} % 12 -- размер шрифта
\usepackage{cmap} % Чтобы можно было копировать русский текст из pdf
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % В частности эта строка отвечает за правильные переносы слов в конце строки
\usepackage[utf8]{inputenc} % Проверьте, что кодировка файла -- тоже utf8
\usepackage{amsmath, amssymb} % Чтобы юзать математические символы
\usepackage{ dsfont }
\usepackage{ wasysym }
\usepackage[makeroom]{cancel}
\usepackage{listings}
\usepackage{tcolorbox}

\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary {positioning}

\newcommand \tab[1][1cm]{\hspace*{#1}}
\def\O{\mathcal{O}}  

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\title{Конспект девятого занятия\\
	\large Бинарный поиск}
\author{Парамонов Антон Игоревич}
\maketitle
\section{Логарифм}
\subsection{Игра}
Представьте следующую игру: играют двое, первый игрок загадывает целое число, скажем, от 1 до 10. Второй игрок пытается это число угадать. Он делает попытки, называя числа, а первый говорит, меньше названное число загаданного или больше или равно. 

Вот пример такой игры. Пусть загадано число 7. Далее последовательность ходов в формате "догадка второго"\ , "ответ первого".\\
$1.\ 3 <\\
2.\ 5 <\\
3.\ 7 \geq\\
4.\ 9 \geq\\
5.\ 8 \geq\\
6.\ 6 <$\\
Твое число 7 $\textcolor{teal}{\checkmark}$\\

Вопрос: а какое минимальное количество ходов понадобится второму, чтобы выиграть? Понятно, что можно действовать примитивно: называть числа от 1 в порядке возрастания, поначалу они все будут меньше загаданного, а как только станет $\geq$, это и будет значить, что мы нашли нужное число. Такая стратегия приводит к успеху, но представьте, что загадано число 9. В таком случае вам понадобится 9 ходов, а это никуда не годится.

Правильную же стратегию можно описать словами "спрашивай среднее". Пусть все еще первый игрок загадал число 7. Для начала спросим 5. Ответ будет $<$. Значит теперь нас интересуют числа $6\ldots10$. Снова спрашиваем среднее: 8. Ответ $\geq$. Диапазон сузился до $6, 7, 8$. Спрашиваем 7, ответ $\geq$. Остались $6, 7$, спросим 6: $<$, значит, осталось единственное число 7. На этот раз всего 4 хода. 

Давайте анализировать наше решение. Каждый раз диапазон, в котором находится загаданное число, уменьшается вдвое. Действительно, мы тыкаем в середину, а дальше, в зависимости от ответа, нам подходит либо левая, либо правая половина. Здесь надо отметить, что иногда диапазон имеет нечетную длину, и после вопроса мы можем остаться в "большей"\ половине, но разница между половинами всего 1 элемент, так что все равно можно считать, что мы уменьшились вдвое. И того: мы сделаем столько ходов, сколько раз нужно поделить на два изначальный диапазон, чтоб осталось всего одно число. Т.е. в случае с диапазоном $1\ldots10$ мы первый раз поделим пополам, останется 5 возможных чисел. Дальше, после деления, нам, возможно, не повезет и мы останемся в большей половине, так что останется 3 числа. Дальше, аналогично, останутся 2 числа и, наконец, четвертым ходом мы из двух чисел выберем нужное. Получается, что за 4 хода мы однозначно отгадаем число, как бы удача от нас не отворачивалась.

А за сколько можно отгадать число из диапазона $1\ldots1000$?\\
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title={Математическая справка. Логарифм.}]
	Вы знакомы с операцией возведения в степень. Логарифмирование - это в каком-то смысле обратная к ней. $\log_{\textcolor{blue}{2}}\textcolor{teal}{8}$ читается как "логарифм 8ми по основанию 2"\ и равен он степени, в которую нужно возвести 2, чтоб получить 8, т.е. $\log_{\textcolor{blue}{2}}\textcolor{teal}{8} = \textcolor{red}{3}$, т.к. $\textcolor{blue}{2}^{\textcolor{red}{3}} = \textcolor{teal}{8}$.
	
	О $\log_b a$ можно думать как "сколько раз нужно поделить $a$ на $b$, чтоб получилась единица".\\
	Логарифм может быть нецелым, например, $\log_2{10} \approx 3.3219280$. Для округления вверх будем использовать обозначение: $\lceil \log_2{10} \rceil = 4$
\end{tcolorbox}
Если бы длина диапазона была степенью двойки, например, 8, ответом к нашей игре было бы $\log_28 = 3$ попытки. Но из-за того, что иногда длина нечетная, и при невезении мы будем переходить в большую половину, логарифм округляется вверх, т.е. для задачи с числами от 1 до 10 ответ $\lceil \log_2{10} \rceil = 4$ попытки.

Соответственно, для чисел из диапазона $1\ldots1000$ нам понадобится $\lceil \log_2{1000} \rceil = 10$ попыток. Не так и много.
\subsection{Сравнение с другими функциями}
"Не так и много"\ - это не просто риторическое замечание. $\log_2{1000000} \approx 19.93$ это совсем мало по сравнению с миллионом, поэтому говорят, что логарифм медленно растет. Чтоб лучше понять суть этой фразы, давайте посмотрим на график.\\
\\
\begin{tikzpicture}
\begin{axis}[
axis lines = left,
xlabel = $x$,
ylabel = {$f(x)$},
]
\addplot [
domain=0:10, 
samples=100, 
color=red,
]
{x^2};
\addlegendentry{$x^2$}

\addplot [
domain=0:10, 
samples=100, 
color=blue,
]
{ln(x) / ln(2)};
\addlegendentry{$\log_2x$}

\addplot[
domain=0:10,
samples=100,
color=green]{x};
\addlegendentry{$x$}

\end{axis}
\end{tikzpicture}

Видно, насколько медленнее по сравнению с уже знакомыми нам функциями растет логарифм.

\section{Бинарный поиск}
\subsection{Общая идея}
Представьте отрезок, который до какого-то момента покрашен в синий цвет, а после - в красный. Мы эту покраску не видим, для нас весь отрезок черный, но мы можем выбрать на нем какую-то точку, и нам скажут, какого она цвета. Задача - найти стык синей и красной частей. Делать нужно точно то же самое, что мы делали, когда угадывали число. Тыкаем в середину, если середина оказалась синей, значит, стык справа. Теперь \underline{сделаем середину новой левой границей}, получим отрезок, который все еще сначала синий, потом красный, но уже в два раза меньшей длины. Аналогично, если середина оказалась красной, только теперь мы \underline{делаем середину новой правой границей}.\\
\\
\begin{tikzpicture}[> = stealth]
\coordinate (a) at (1,2.1);
\coordinate (b) at (7,2.1);
\coordinate (c) at (5,2.1);

\draw[ultra thick, line width=1.25mm, blue]  (a) -- (c);
\draw[ultra thick, line width=1.25mm, red]  (c) -- (b);
\filldraw [black] (4,2.1) circle (3pt);

\coordinate (d) at (1,3.5);
\coordinate (e) at (5,3.5);
\coordinate (f) at (7,3.5);

\draw[ultra thick, line width=1.25mm, blue]  (d) -- (e);
\draw[ultra thick, line width=1.25mm, red]  (e) -- (f);

\coordinate (g) at (4,0.7);
\coordinate (h) at (5,0.7);
\coordinate (i) at (7,0.7);

\draw[ultra thick, line width=1.25mm, blue]  (g) -- (h);
\draw[ultra thick, line width=1.25mm, red]  (h) -- (i);

\coordinate (j) at (4,-0.8);
\coordinate (k) at (5,-0.8);
\coordinate (l) at (7,-0.8);

\draw[ultra thick, line width=1.25mm, blue]  (j) -- (k);
\draw[ultra thick, line width=1.25mm, red]  (k) -- (l);
\filldraw [black] (5.5,-0.8) circle (3pt);

\coordinate (m) at (4,-2.3);
\coordinate (n) at (5,-2.3);
\coordinate (o) at (5.5,-2.3);

\draw[ultra thick, line width=1.25mm, blue]  (m) -- (n);
\draw[ultra thick, line width=1.25mm, red]  (n) -- (o);
\end{tikzpicture}\\
Видно, что отрезок уменьшается, а мы приближаемся к стыку. В задачах на бинпоиск нужно понять, что является отрезком, а что синим и красным цветами. В нашей игре "угадай число"\ отрезок - диапазон чисел, синий цвет - числа меньше загаданного, красный цвет - числа больше либо равные загаданному. 
\subsection{Реализация}
Давайте решим следующую задачу: на вход подаются два числа - n и k, а затем n целых чисел в порядке возрастания. Надо среди этих n чисел найти наибольшее число, меньшее либо равное k. \newpage
\begin{lstlisting}[language=Python]
n, k = [int(i) for i in input().split()]
arr = [int(i) for i in input().split()]

l = 0
r = n
while r - l > 1:
	m = (r + l) // 2
	if arr[m] > k:
		r = m
	else:
		l = m

print(arr[l])
\end{lstlisting}
Первая строчка - способ считать два числа, записанные в строку через пробел. В четвертой и пятой строчках устанавливаем границы поиска: искомое число лежит где-то между нулевым (включительно) и n-ным (не включительно) элементами массива.

Пока мы не сузили диапазон поиска до единственного элемента (6ая строчка) берем середину (7ая строчка) и проверяем, правда ли, что элемент массива из середины актуального диапазона больше k (8ая строчка). Если больше, то интересующее нас число лежит в левой половине диапазона, так что делаем середину правой границей (9ая строчка), а если меньше, то середину делаем левой границей (11ая строчка).

В итоге получили $r - l == 1$, так что, т.к. $r$ мы не включаем, наш диапазон состоит из единственного элемента arr[$l$], он и будет правильным ответом. Предлагаю читателю вручную проделать все шаги алгоритма на каком-нибудь небольшом примере.

\subsection{Бинпоиск по ответу}
Для иллюстрации следующей идеи отлично подходит прыгун в высоту. Представьте, что спортсмену нужно выяснить, какую наибольшую высоту он способен взять. Вы знаете, что ответ лежит где-то в диапазоне от 0см до 300см. Это и будет нашим отрезком. Синей его частью будут высоты, которые прыгун берет, красной - ему не покорившиеся, нас интересует стык. Начнем бинпоиск. Поставим планку на 150см, попросим атлета прыгнуть. Если высота взята, переместим планку на 225см, иначе на 75см. И так далее.

В абстрактном случае такой подход полезен, когда мы легко можем проверить, меньше данное число искомого или больше или равно. Тогда делаем бинпоиск по интервалу возможных ответов и на каждом шаге запускаем процесс проверки, по результатам которого двигаем ту или иную границу. Еще одним жизненным примером является процесс поиска страницы книги, на которой вы остановились.

\subsection{Сложность}
Из всего сказанного выше очевидно, но стоит явно отметить, что сложность бинарного поиска - $\O(\log_2 n)$. На самом деле, $\log_an$ отличается от $\log_bn$ (для каких-то конкретных a и b) в константу раз (это доказывают классе в 10, но нам это не особо важно, так что просто поверим), поэтому, т.к. в О-нотации не важны константы, получается, что и не важно, какое основание, так что пишут $\O(\log n)$.
\end{document}