\documentclass[12pt]{article} % 12 -- размер шрифта
\usepackage{cmap} % Чтобы можно было копировать русский текст из pdf
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % В частности эта строка отвечает за правильные переносы слов в конце строки
\usepackage[utf8]{inputenc} % Проверьте, что кодировка файла -- тоже utf8
\usepackage{amsmath, amssymb} % Чтобы юзать математические символы
\usepackage{ dsfont }
\usepackage{ wasysym }
\usepackage[makeroom]{cancel}
\usepackage{listings}
\usepackage{tcolorbox}

\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary {positioning}

\newcommand \tab[1][1cm]{\hspace*{#1}}
\def\O{\mathcal{O}}  

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\title{Конспект восьмого занятия\\
	\large Введение в сложность}
\author{Парамонов Антон Игоревич}
\maketitle

\section{Делители числа}

Компьютеры считают очень быстро. Разумеется, конкретные показатели зависят от многих факторов, но в среднем можно говорить о $\approx 10^7$ операциях в секунду. Под операциями имеются в виду всяческие арифметические действия, присваивания, if-ы и т.п. $10^7$ это много. Однако, и задачи перед компьютерами ставятся соответствующие, так что время работы, бывает, достигает нескольких месяцев. Также, например, из-за большой нагрузки может лагать ваша любимая игра или медленно скачиваться фильм. Поэтому крайне важно писать такие программы, в которых компьютер будет выполнять как можно меньше операций.

Давайте рассмотрим следующую задачу: узнать, простое ли число. Эту задачу можно решить прямо:
\begin{lstlisting}[language=Python]
n = int(input())

hasDivisor = False
for i in range(2, n):
	if n % i == 0:
		hasDivisor = True

if hasDivisor:
	print("Not prime")
else:
	print("Prime")
\end{lstlisting}

Здесь мы ввели так называемый "флаг"\ - переменную, значение которой может измениться в цикле. Флаг будет индикатором того, есть ли у числа делители. Изначально \textit{hasDivisor} = False, но если, перебирая все числа от $2$ до $n - 1$, мы найдем делитель $n$, то сделаем \textit{hasDevisor} равным True. После чего, в зависимости от значения \textit{hasDevisor}, выведем, простое введенное число или нет.

Это правильное, но долгое решение. На практике (преимущественно в криптографии) на простоту проверяют очень большие числа. Если нашему алгоритму дать число порядка $10^{12}$, то у нас получится цикл длины $10^{12} - 2$, плюс еще какие-то операции, для удобства будем считать, что операций будет ровно $10^{12}$, т.к. когда речь идет о триллионах $\pm 10$ операций ни на что не влияют. Вспомним, что я говорил, что компьютер может выполнять $\approx 10^7$ операций в секунду, получим $10^5$ секунд $\approx$ 28 часов на решение задачи. Неприемлемо.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title={Математическая справка. Делители числа.}]
	Пусть дано какое-то число $n$. Можно заметить, что если у числа есть делитель, отличный от самого $n$ и единицы, то обязательно есть делитель $\leq \sqrt{n}$. \\
	
	Действительно, пусть $n\ \vdots\ d$ ($n$ делится на $d$) и $\frac{n}{d} = q$. $q$ - также делитель $n$, потому что $\frac{n}{q} = d$, т.е. $n = q \cdot d$. Но если $q > \sqrt{n}$ и $d > \sqrt{n}$, то  $q \cdot d > \sqrt{n} \cdot \sqrt{n} = n$, противоречие. Значит, либо $d$, либо $q \leq \sqrt{n}$.  $\blacksquare$
\end{tcolorbox}

Получается, что чтобы проверить, есть ли у числа делители, достаточно искать их до корня, т.е. вместо $10^{12}$ делать $10^6$ операций и вместо 28ми часов решать задачу $0.1$ секунду.

Реализовать алгоритм перебора до корня вам предстоит самостоятельно. Полезно помнить, что цикл может быть от и до лишь целых чисел, поэтому нужно перебирать не конкретно до корня, а до округленного корня.

\section{O-нотация}
Первая версия нашего алгоритма работала за время (будем отождествлять понятия времени и количества операций) прямо пропорциональное размеру введенного числа. Т.е. если бы $n$ оказалась равно 100, алгоритм выполнил бы $\approx 100$ операций, если бы $n$ оказалось равно $10^6$, то алгоритм выполнил бы $\approx 10^6$ операций. В случае же перебора до корня, алгоритм работает за время прямо пропорциональное $\sqrt{n}$, т.е. при $n = 10^6$ алгоритм сделает $\approx 1000$ операций. 

Для краткости слова "прямо пропорционально"\ заменяют буквой $\O$, после которой в скобках пишут прямо пропорционально чему. В такой записи первый алгоритм работает за $\O(n)$, а второй за $\O(\sqrt{n})$.\\

\subsection{Считаем примерно}
Важно понимать, что О-нотация "съедает"\ некоторые операции. Так например, в ней не учитывается, что мы должны считать число, потому что это "простая"\ операция, и если после этого мы делаем цикл длины считанное число, то программа будет иметь сложность $\O(n)$, без всяких +2 на ввод и вывод. Другое дело, если мы считываем $n$ чисел.

Такие опущения позволительны, поскольку, как уже говорилось, при работе с порядками $10^6$ $\pm2$, да хоть $\pm100$ операции, не играет роли, а анализировать время работы программы становится куда проще.\\

На самом деле в О-нотации пренебрегают даже множителем. Так например, $\O(2n)$ - это тоже самое, что  $\O(n)$. Такие пренебрежения зачастую уже заметны на практике, однако теоретиков не интересуют по нескольким причинам. Во-первых, в компьютеры встроены множественные оптимизации, и сколько в действительности будет выполнено операций, сказать нереально, так что такая точность, как сомножитель, просто является излишней. Во-вторых, $2n$ операций "по духу" куда ближе к $n$ операциям, чем, скажем, к $n^2$. Действительно, если $n$ порядка 1000, то $2n$ - это 2 тысячи, а $n^2$ - это миллион.\\

Заметьте, что все мои объяснения, почему мы можем пренебрегать теми или иными числами, работают исключительно на больших числах. Например, если $n = 1$, то $2n$ вообще больше, чем $n^2$. Однако, компьютеры работают именно с большими числами, которые и "давят"\ вклад числовых слагаемых и сомножителей.

\section{Вложенные циклы}
Раньше мы не заостряли на этом внимания, но внутри цикла может быть еще один цикл
\begin{lstlisting}[language=Python]
n = int(input())
m = int(input())
for i in range(1, n + 1):
	for j in range(1, m + 1):
		if i + j == 5:
			print(i, j)

#Input:
#3
#4
#Output:
#1 4
#2 3
#3 2
\end{lstlisting}

Эта программа берет на вход два числа n и m, перебирает i от 1 до n, \underline{для каждого i} перебирает j от 1 до m, и если i + j == 5, печатает i и j.

Несложно понять, что если внешний цикл имеет длину n, а внутренний m, то такая программа отработает за $\O(n \cdot m)$. Вот табличка, отражающая процесс работы этой программы для n = 3, m = 4
\begin{tabular}{|c|c|c|}
	\hline
	\textit{i} & \textit{j} & i + j == 5\\
	\hline
	\hline
	1 & 1 & \textcolor{red}{False}\\
	\hline
	1 & 2 & \textcolor{red}{False}\\
	\hline
	1 & 3 & \textcolor{red}{False}\\
	\hline
	1 & 4 & \textcolor{teal}{True}\\
	\hline
	2 & 1 & \textcolor{red}{False}\\
	\hline
	2 & 2 & \textcolor{red}{False}\\
	\hline
	2 & 3 & \textcolor{teal}{True}\\
	\hline
	2 & 4 & \textcolor{red}{False}\\
	\hline
	3 & 1 & \textcolor{red}{False}\\
	\hline
	3 & 2 & \textcolor{teal}{True}\\
	\hline
	3 & 3 & \textcolor{red}{False}\\
	\hline
	3 & 4 & \textcolor{red}{False}\\
	\hline
\end{tabular} Как видно, в ней ровно $m \cdot n = 3\cdot 4 = 12$ строк.\\

Вложенные циклы - это произведение. Циклы, следующие друг за другом - сумма. Поэтому, скажем, если вы сначала считали массив чисел длины $n$, а затем прошлись по нему пару раз, вы потратили $n + n + n = \O(n)$ операций. 
 
Другое дело, если три цикла оказались вложенными. Тогда сложность вашей программы уже $n \cdot n \cdot n = \O(n^3)$, что при $n = 1000$ не под силу компьютеру за короткое время, тогда как $3000$ отработают за $\approx0.001$ секунду.
\end{document}