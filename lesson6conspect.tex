\documentclass[12pt]{article} % 12 -- размер шрифта
\usepackage{cmap} % Чтобы можно было копировать русский текст из pdf
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % В частности эта строка отвечает за правильные переносы слов в конце строки
\usepackage[utf8]{inputenc} % Проверьте, что кодировка файла -- тоже utf8
\usepackage{amsmath, amssymb} % Чтобы юзать математические символы
\usepackage{ dsfont }
\usepackage{ wasysym }
\usepackage[makeroom]{cancel}
\usepackage{listings}
\usepackage{tcolorbox}

\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary {positioning}

\newcommand \tab[1][1cm]{\hspace*{#1}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\title{Конспект шестого занятия\\
	\large Динамическое программирование}
\author{Парамонов Антон Игоревич}
\maketitle
\section{Последовательности}
Есть много разных числовых последовательностей. Например, $1, 2, 3, 4\ldots$, $1, 3, 5, 7\ldots$, $1, 3, 9, 27, 81\ldots$. Все три последовательности бесконечные, но вы, увидев только первые четыре числа, должно быть, сможете сказать и все остальные. В первом случае это просто все числа подряд, во втором - все нечетные, в третьем - следующее число - утроенное предыдущее. Чтобы описать последовательность, нужно \underline{задать ее каким-то правилом}. Есть два основных способа.
\begin{enumerate}
	\item Сказать, чему равно число на i-ой позиции. Например, в первой последовательности число на 1ой позиции равно одному, на второй - 2ум, на сотой - 100.
	\item Сказать, чему равно первое число и ввести правило, как по числу последовательности получить следующее. Так, например, в 3ей последовательности первое число равно 1, а все остальные получаются из предыдущих домножением на 3.
\end{enumerate} 
Давайте разберем наши примеры в описанных терминах. i-ое число последовательности будем обозначать $a_i$. \\
\\
\begin{tabular}{|l|l|l|}
	\hline
	Последовательность & Первый способ & Второй способ \\
	\hline 
	\hline
	$1, 2, 3, 4, 5\ldots$ & $a_i = i$ & $ a_1 = 1, \ a_{i} = a_{i -1} + 1$\\
	\hline
	$1, 3, 5, 7, 9\ldots$ & $a_i = 2i - 1$ & $a_1 = 1, \ a_{i} = a_{i -1} + 2$\\
	\hline
	$1, 3, 9, 27, 81\ldots$ & $a_i = 3^{i - 1}$ & $a_1 = 1, \ a_{i} = a_{i -1} \cdot 3$\\
	\hline
	$1, 4, 9, 16, 25\ldots$ & $a_i = i^2 $ & $a_1 = 1, \ a_{i} = a_{i -1} + 2i + 1$\\
	\hline
\end{tabular}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title={Математическая справка. Числа Фибоначчи.}]
	Числа Фибоначчи - это, наверное, одна из самых известных последовательностей чисел. Ее намного удобнее задавать именно вторым способом. Вот как определяются числа Фибоначчи\\
	$F_1 = 1,\  F_2 = 1,\ F_{i} = F_{i - 2} + F_{i - 1}$\\
	Число Фибоначчи - это сумма двух предыдущих чисел Фибоначчи. Заметим, что чтобы говорить 'двух предыдущих', нам нужно задать значение не только первому числу, но и второму, и только начиная с третьего пользоваться формулой.\\
	Если вам интересно, вот как задаются числа Фибоначчи первым способом\\
	$F_i = \frac{1}{\sqrt{5}} ((\frac{1 + \sqrt{5}}{2})^i - (\frac{1 - \sqrt{5}}{2})^i)$. Второй явно приятней.\\
	\\
	\textit{Анекдот}\\
	Салат Фибоначчи. Остатки вчерашнего салата смешиваем с остатками позавчерашнего. Хаха.
\end{tcolorbox}
\subsection{Программируем последовательности}
Давайте научимся вычислять последовательности на \textit{Python}. Во всех примерах нам на вход подается одно число - номер элемента последовательности. Программа должна вывести элемент с данным номером.\\
Последовательность $1, 3, 5, 7, 9 \ldots$ \\
Первым способом.
\begin{lstlisting}[language=Python]
n = int(input())
print(2 * n - 1)
\end{lstlisting}
Вторым способом.
\begin{lstlisting}[language=Python]
n = int(input())
a = [0] * (n + 1)
a[1] = 1
for i in range(2, n + 1):
	a[i] = a[i - 1] + 2
print(a[n])
\end{lstlisting}
Во второй строчке мы создаем массив, в котором и будут лежать члены нашей последовательности. Изначально он заполнен нулями и имеет длину $n + 1$, это значит, что последний элемент - $n$-ый, т.к. нумерация, напомню, с нуля. Благодаря такому формату массива мы можем работать с элементами с 1-ого по $n$-ый вместо 0-ого по $n-1$-ый, что в случае с последовательностями особенно наглядно.\\
В третьей строчке мы говорим, чему равен первый элемент последовательности. Теперь в цикле считаем значение всех, начиная со второго по $n$-ый, отсюда такой \textcolor{red}{range}. Мы считаем значение $i$-ого, опираясь на значение $i-1$-ого.\\
По окончании работы цикла насчитанная последовательность хранится в массиве, т.е. $a[i] = a_i$. Нас просили вывести $n$-ый элемент, так что \textcolor{red}{print}(a[n])

\section{Динамическое программирование}
Динамическое программирование или динамика - это, по сути, придумывание и подсчет последовательностей для разных практических задач, в которых, на первый взгляд, никаких последовательностей нет. Вот пример такой задачи
\begin{tcolorbox}[colback=white, colframe=black]
	\textit{Задача}\\
	Кузнечик прыгает по столбикам, расположенным на одной линии на равных расстояниях друг от друга. Столбики имеют порядковые номера от 1 до N . В начале Кузнечик сидит на столбике с номером 1. Он может прыгнуть вперед на расстояние от 1 до 3 столбиков, считая от текущего. Требуется найти количество способов, которыми Кузнечик может добраться до столбика с номером N . Учитывайте, что Кузнечик не может прыгать назад. 
\end{tcolorbox}
Где здесь последовательность? - спросите вы. Ключевой вопрос. Пусть $a_i$ - количество способов кузнечику попасть на $i$-ый столбик. Считать последовательность будем вторым способом, так что теперь нужно придумать, как узнать $a_i$, если мы знаем все предыдущие значения. Попасть на $i$-ый столбик можно с $i-1$-ого, $i-2$-ого и $i-3$-его. Попасть на $i$-ый столбик через $i-1$-ый можно ровно тем же количеством способов, что и попасть на $i-1$-ый: нужно сначала попасть на $i-1$-ый, а потом прыгнуть на 1 вперед. Аналогично с $i-2$-ым и $i-3$-им. Т.е. количество способов попасть на $i$-ый столбик - это суммарное количество способов для $i-1$-ого, $i-2$-ого и $i-3$-его. Вот мы и научились считать $a_i$, зная предыдущие. $a_i = a_{i - 1} + a_{i - 2} + a_{i - 3}$. Напоминает Фибоначчи. Остается заметить, что на первый столбик у кузнечика попасть всего один вариант - он уже там сидит. \underline{Если мы ссылаемся на предыдущие значения, мы должны быть}\\ \underline{уверены, что они существуют!} Если мы по нашей формуле захотим посчитать значение для 2ого элемента, получится что-то очень странное: $a_2 = a_1 + a_0 + a_{-1}$. Никаких $a_0$ и $a_{-1}$ у нас нет. Так что формула применима только начиная с $i = 4$. Для первых же трех, например, можно просто посчитать значение вручную. И так\\
\fbox{$a_1 = 1,\  a_2 = 1,\ a_3 = 2,\ a_i = a_{i - 1} + a_{i - 2} + a_{i-3}$ }\\
\\
Однако при написании кода мы будем немного иначе бороться с тем, что формула не работает для второго и третьего чисел.
\subsection{Программируем динамику}
Напишем код для кузнечика
\begin{lstlisting}[language=Python]
n = int(input())
a = [0] * (n + 1)
a[1] = 1
for i in range(2, n + 1):
	a[i] = a[i - 1]
	if i > 2:
		a[i] = a[i] + a[i - 2]
	if i > 3:
		a[i] = a[i] + a[i - 3]
print(a[n])
\end{lstlisting}
Строчки с 6ой по 9ую отражают следующую идею: в $a[i]$ точно будет $a[i-1]$, т.к. $i$ от 2ух. Если $i > 2$, то в $a[i]$ будет еще и $a[i - 2]$, аналогично если $i > 3$, то к $a[i]$ нужно прибавить $a[i - 3]$. Почему не указать явно, чему равны $a[1],\ a[2],\ a[3]$? Потому что после того, как мы создали массив из $n + 1$-ого элемента, например, при $n = 2$, $a[3]$ просто не существует.\\
Последовательность $a_i$ лежит в массиве, т.е. $a_i = a[i]$, а просили нас вывести, сколькими способами кузнечик может допрыгать до $n$-ого столбика, это у нас $a_n$, \textcolor{red}{print}$(a[n])$\\
Вот пример итогового массива для n = 6.\\
\\
\begin{tabular}{|c|c|c|c|c|c|c|}
	\hline
	0 & 1 & 1 & 2 & 4 & 7 & 13\\
	\hline
\end{tabular}\\
\\
В \underline{нулевой} ячейке лежит 0, т.к. ее мы не трогали, а для удобства работали с ячейками с 1 по 6ую. 
\end{document}